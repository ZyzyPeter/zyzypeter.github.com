#Pyhton NumPy的ndarray
numpy的一个很重要的特点是它的n维数组对象ndarray，它在用于大数据处理时的性能甚至要高于python自己内置指的数据结构。

###创建一个ndarray
首先我们用一个列表来创建一个ndarray，当然进行这个操作的时候需要`import numpy`，或者`import numpy as np`书上推荐后者，也是比较流行的导入numpy模块的格式,然后使用它的array方法。
```
import numpy as np
data=[[1,2,3],[4,5,6]]
array1=np.array(data)
print data
>>[[1 2 3]
 [4 5 6]]
```

ndarray有两个方法表示它的当前属性，一个是shape，表示各维度的大小，另外一个是dtype，表示它包含的数据类型，一个ndarray里面所有数据的类型都是相同的。
```
print array1.shape
print array1.dtype
>>(2L, 3L)
int32
```
另外，我们可以使用zeros和ones方法来分别创建全0或全1数组，在创建这些数组的时候，只需要传入表示维数的元组即可
```
arr2=np.zeros((1,2,3))
print arr2
>>[[[ 0.  0.  0.]
  [ 0.  0.  0.]]]
```
还有empty方法，用法同zeros和ones它可以返回对应的充满未初始化的垃圾值的数组。

如果要生成一个递进序列数组，就可以使用arange方法，它是python内置的range方法的数组版本。
```
print np.arange(5,9)
>>[5 6 7 8]
```
但是不同与前几个方法，它不能产生多维递进数组。

另外，还有like类型的方法，包括zeros_like,ones_like,empty_like,向他们传入一个数组，它们能根据这个数组的shape和dtype创建一个相同模式的全0全1或未初始化数组。
asarray方法则可以将输入转换成ndarray
eye和identity方法，创造一个输入维数的单位矩阵
```
print np.identity(3)
print np.eye(2)
>>[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]
[[ 1.  0.]
 [ 0.  1.]]
```

还有numpy.random.randn方法，传入维数便可以生成对应维度的随机数数组

###ndarray的dtype
dtype是numpy自带的一类数据类型，大多数情况下，dtype类的数据直接映射在相应的机器表示，它们的命名方式前半部分是一个常见的类型名，后半部分会跟着一个用于表示元素位长的数字。
```
int32
int64
float64
```
我们可以使用asdtype显式转换ndarray的dtype
```
arr1.asdtype(int32)#这里写int其实具有一样的效果
```
类型转换的规则大同小异，不再赘述。

在使用创建数组的方法时，也可以加入dtype参数来指定要创建的数组的数据类型
```
arra3=np.array([1,2,3],dtype=np.float64)
```

###数组的运算
ndarray数组可以直接作为一个类型进行数学运算，同维数组运算的规律就是在相同位置上的数字的数学运算。而对于不同维的数组，则会有一种广播机制作为运算规律，目前没学，暂略。

###数组的切片
```
array2=np.arange(10)
print array2[5]
print array2[5:8]
array2[5:8]=12
print array2
>>5
[5 6 7]
[ 0  1  2  3  4 12 12 12  8  9]
```
数组的切片与赋值都是在原始数据上操作，因此，返回的数组又称为原数组的视图。这意味着要对原始数组进行备份的话需要用`array_slice=array2[5:8].copy()`进行显式复制。

###数组的索引
访问多维数组元素时，使用它当前维度的上一维数组来表示
```
data=[[1,2,3],[4,5,6]]
array1=np.array(data)
print array1[0]
print array1[0][2]
print array1[0,2]
>>[1 2 3]
3
3
```
访问时给他们进行赋值，同样有广播的效果。

切片和索引可以在访问数组时混合使用，像是`array[:1,2,6:7]`，相当灵活。

###布尔型索引

在对数组进行比较运算的时候，和算术运算一样，都是可以直接进行的。
```
data=[[1,2,3],[4,5,6]]
array1=np.array(data)
print array1==2
>>[[False  True False]
 [False False False]]
```
不仅如此，我们还可以利用这个布尔数组来作索引，True值在布尔数组中的位置就可以看成是索引引用的位置。
```
data=[[1,2,3],[4,5,6],[7,8,9]]
array1=np.array(data)
array2=np.array([2,0,2])
print array2==2
print array1[array2==2]
>>[ True False  True]
[[1 2 3]
 [7 8 9]]
```
而且布尔型索引一样可以进行切片。

有了布尔型索引，我们往往就可以有条件的操作数组中对应的某一些值，例如把数组中所有小于0的数设置为0`array[array<0]=0`,不过在这里面，只能使用|和&进行逻辑或和逻辑与运算，and和or是不能够使用的。

###花式索引
花式索引是一个numpy术语，表示用整数数组进行索引。
```
data=[[1,2,3],[4,5,6],[7,8,9]]
array1=np.array(data)
print array1[[1,2]]
print array1[[1,2][1]]
>>[[4 5 6]
[7 8 9]]
>>[7 8 9]
```
还可以通过传入负整数来从后往前索引。
```
data=[[1,2,3],[4,5,6],[7,8,9]]
array1=np.array(data)
print array1[[1,2]]
print array1[[-1,-2]]
>>[[4 5 6]
 [7 8 9]]
>>[[7 8 9]
 [4 5 6]]
```
花式索引与普通索引和切片不一样，它创建了一个新的数组。

值得注意的是，使用形似[[0,1,2],[0,1,2]]这样的花式索引时，实际上选取的是(0,0),(1,1),(2,2)的三个索引组合，
```
data=[[1,2,3],[4,5,6],[7,8,9]]
array1=np.array(data)
print array1[[1,2],[1,2]]
>>[5 9]
```
注意这里[1,2]与[1,2]之间有个逗号。

###数组转置与轴对换

这里的转置与线性代数上矩阵的转置意义是一样的，并且这个操作是在原数组上进行操作，返回的是原数组的视图。
```
data=[[1,2,3],[4,5,6],[7,8,9]]
array1=np.array(data)
print array1.T
print array1
>>[[1 4 7]
 [2 5 8]
 [3 6 9]]
>>[[1 2 3]
 [4 5 6]
 [7 8 9]]
```
.T对数组进行简单的轴对换。
而对于高维数组，则有transpose方法，通过传入一个由轴编号组成的元组来对这些轴进行转置。
```
data=[[[0,1,2],[3,4,5]],[[6,7,8],[9,10,11]]]
array1=np.array(data)
print array1.transpose((1,0,2))
>>[[[ 0  1  2]
  [ 6  7  8]]
 [[ 3  4  5]
  [ 9 10 11]]]
```
这个比较费脑，仅说轴0轴1轴2可能会想不太清楚，但我们可以这样想，二维数组是数组在平面上的延展，轴0就是x轴，轴1就是y轴
```
	  	 x轴/轴0
y轴/轴1 |————————————————————————————>
       |
       |
       |
       |
       |
```
然后三维数组就是加了一条z轴，轴2
```
   /
  /------6----7----8
 / z轴  /    /    /
/	  9   10   11
————————————————————————————>
|----0----1----2
|    |    |    |
|	3	4	5
|
|
```
然后传入轴编号(1,0,2)实际上是指(y轴，x轴，z轴)也就是让y轴和z轴以x轴为轴心转置。对于高于三维的，图形上虽然无法想象，但是概念上是差不多的。
（灵魂画师）
另外，还有一个swapaxes方法，它接受一对轴编号。
```
data=[[[0,1,2],[3,4,5]],[[6,7,8],[9,10,11]]]
array1=np.array(data)
print array1.swapaxes(1,2)
>>[[[ 0  3]
  [ 1  4]
  [ 2  5]]

 [[ 6  9]
  [ 7 10]
  [ 8 11]]]
```